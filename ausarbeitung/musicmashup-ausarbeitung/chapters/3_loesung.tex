\section{Aufgabenstellung}


Wir haben uns zum Ziel gesetzt, einen vollwertigen Musikempfehlungsdienst zu entwickeln, welcher auf Basis von Linked Data arbeitet. Inspiriert ist dies durch den Internetdienst Musicbrainz (Q5). Dabei handelt es sich um eine offene Musik-Enzyklopädie, die zahlreiche Informationen zu Musikern und Bands anbietet. Dazu zählen Informationen wie ein kurzer Abstract, eine Discographie, externe Links, eine Liste aller aktueller und ehemaliger Mitglieder der Band etc. Sucht man auf Musicbrainz zum Beispiel nach der Band “Queens of the Stone Age”, sieht man dort, dass Josh Homme das einzige verbliebene Gründungsmitglied der Band ist. Mit einem Klick auf den Namen wird man zur Seite von Josh Homme weitergeleitet. Dort sieht man unter Anderem in welchen anderen Bands er gespielt hat und kann sich wiederum Informationen zu diesen ansehen.


Der Benutzer kann also ausgehend von einem Interpreten weitere entdecken. Genau diese Möglichkeit soll auch MusicMashup bieten. Der Benutzer gibt den Names eines Interpreten ein und bekommt passend zu diesem Empfehlungen. Klickt er eine dieser Empfehlungen an, werden ihm wiederum für diesen Interpret Empfehlungen angezeigt. 


Erweitert wird dies durch zusätzlichen Informationen und Funktionen. Die wohl wichtigste Zusatzfunktion ist ein eingebundener Spotify-Player, welcher die Möglichkeit bietet, sich direkt Musik des jeweiligen Künstlers anzuhören. Darüber hinaus wird eine Liste mit anstehenden Konzerten ausgegeben, sowie weiterführende Links, eine Bildergalerie und ein kurzer Abstract über den Artist. Damit der Benutzer nachvollziehen kann, wie er von einem Interpreten zum Nächsten gekommen ist, wird im Header der Seite eine Liste der zuvor betrachteten Interpreten angezeigt.

\subsection{Technische Grundlagen des Servers}

MusicMashup ist als so genannte Web-App realisiert und präsentiert sich dem Benutzer als interaktive Website, die er aus seinem Browser nutzen kann.

Die programmatische Grundlage von MusicMashup bildet ein in Python geschriebener 
HTTP-Server basierend auf dem cherrypy-Modul (Q6). Dieser Server wertet die Nutzeranfrage aus, führt die entsprechenden Abfragen durch und liefert die daraus generierten Empfehlungen mittels der Template-Engine mako (Q7) als Website aus. 

\subsection{Klassenstruktur}


Das System besteht aus vier Klassen: MusicMashupServer, MusicMashupArtist, MusicMashupParser und MusicMashupPagerank (siehe Abb. x).


Bild: Klassendiagramm


Die Klasse $MusicMashupServer$ stellt den Web-Server bereit und löst bei einem Aufruf der Anwendung weitere Funktionen aus. Wird nach einem Interpreten gesucht, wird für diesen Interpreten ein Objekt vom Typ MusicMashupArtist erstellt. Diesem wird entweder die Suchanfrage oder aber eine aus einer Empfehlung stammende DBpedia-URL übergeben, sollte eine Empfehlung angeklickt worden sein. Die eigentliche Programmlogik geschieht dann in diesem Objekt. Nachdem diese ausgeführt wurde, wird anschließend das HTML-Dokument gerendert und an den Browser ausgeliefert.


Die Klasse $MusicMashupArtist$ dient als Repräsentation eines Artists. Sie implementiert alle Queries, mittels derer Informationen über einen Artist gefunden werden und speichert diese. Darüber hinaus stellt sie Funktionen bereit, die es dem HTML-Template ermöglichen, diese Informationen abzufragen, um sie anschließend anzeigen zu lassen.


Die Klasse $MusicMashupParser$ ist eine simple Implementierung eines Parser, der die Informationen, die wir zu den Artists finden, in eine Turtle-Datei (.ttl) schreibt. Bei Turtle handelt es sich um eine Syntax des rdf-Formats, welche eine Repräsentation eines Rdf-Graphen in Textform ermöglicht (Q15). Das Parsen geschieht aus zwei Gründen: erstens liegt nicht jede der Datenquellen in Form von Linked Data vor. Der Parser überführt die Informationenin ein solches Turtle-FIle und ermöglicht so eine Bereitstellung der Daten als Linked Data.  Zweitens kann beim Aufruf eines Artists überprüft werden, ob bereits eine Turtle-Datei existiert, in dem die Informationen bereits zu Verfügung stehen. Falls ja, können diese aus der Turtle-Datei geladen werden, was zu einer deutlichen Verringerung der Ladezeit führt.


Die Klasse $MusicMashupPagerank$ wird einmalig beim Aufruf der Anwendung instanziiert und dient als Schnittstelle zum Dump der DBPedia-Pageranks, welche in einen Graphen geladen werden und somit zum Abfragen bereitstehen.

\subsection{Datensätze}

Musicbrainz verwendet IDs, um Artists eindeutig zu identifizieren. Diese IDs wurden von vielen anderen Musikdiensten zur Identifikation von Artists übernommen. Um diese zu erhalten wird eine Anfrage auf DBTune (siehe Q12 Alle anderen Datenquellen brauchen auch noch n Link/Quelle)[d] gestellt. Dabei handelt es sich um ein Linked Data Mapping der Musicbrainz Datenbank. Bei einer erfolgreichen Abfrage erhält das System die MusicbrainzID und über owl:sameAs den Link zur entsprechenden DBPedia Ressource. Da DBTune jedoch nicht vollständig ist (zum Beispiel enthält DBTune keinen Eintrag für die Band "Them Crooked Vultures"), wird als Fallback ein Linked Data Dump der Musicbrainz Datenbank benutzt. Zwar gibt es in vielen Fällen, in denen es keinen Eintrag auf DBTune gibt, einen Eintrag im Musicbrainz Dump, jedoch hält der Dump keinen Verweis auf DBPedia, weswegen er schlussendlich nur als Fallback zum Einsatz kommt.
Als Hauptdatenquelle kommt DBPedia zum Einsatz. Von der DBPedia erhält unser System zu einem Interpreten den Abstract, eine Liste der aktuellen und ehemaligen Bandmitglieder sowie ein Thumbnail.[e][f]
Um die bereits vorher genannten zusätzlichen Informationen und Funktionen bereitzustellen, musste auf Datenquellen zurückgegriffen werden, die nicht im Linked Data Format vorliegen. Dazu gehören Spotify (Q8) für den Musikplayer, Songkick (Q9) für zukünftige Konzerte und Echonest (Q10). Echonest dient einerseits als Schnittstelle zu den anderen APIs, andererseits liefert es auch einen sogenannten “Familiarity”-Wert, welcher benutzt wird, um die Relevanz der gefunden Empfehlungen zu bewerten (dazu später mehr).
Weiterhin kommen die DBPedia-Commons (siehe http://commons.dbpedia.org/) sowie ein Dump der DBPedia-Pageranks zum Einsatz. DBPedia-Commons stellt die Wikimedia-Commons als Linked Data bereit. Diese werden benutzt, um zu einer Band Bilder in einer Bildergallerie bereit zu stellen, sollten welche vorliegen. 
Der Dump der DBPedia-Pageranks, welcher von der Semantic-Technologies-Forschungsgruppe des Hasso-Plattner-Instituts bereitgestellt wurde, hält für jede DBPedia-Ressource einen Eintrag über ihren Pagerank. MusicMashup verwendet diesen Dump, reduziert auf Ressourcen mit dem rdf:type Band, MusicalArtist bzw. Artist.
(Q16: Citation
If you are using any of these datasets please cite as:


{dbpedia-graphmeasures,
Author = {Dinesh Reddy, Magnus Knuth, Harald Sack},
Title = {DBpedia GraphMeasures},
Location = {http://semanticmultimedia.org/node/6},
Resource type = {dataset},
Publisher = {Hasso Plattner Institute},
Publication date = {July 2014},
})


\subsection{Funktionsweise}


Beim erstmaligen Aufruf von MusicMashup wird dem Benutzer eine einfach gestaltete Startseite präsentiert, auf der mittels eines Eingabefelds nach einem Artist (siehe Glossar) suchen kann, zu dem er sich Empfehlungen geben lassen möchte.


Bild: Startseite


Der vom Benutzer eingegeben Input wird zunächst in Titlecase überführt. D.h., dass alle Wortanfangsbuchstaben der Eingabe in Großbuchstaben überführt werden, außer es handelt sich um Artikel oder Präpositionen. Wir haben bei unserer Arbeit feststellen können, dass sich somit mehr als 95% aller Künstler zuverlässig finden lassen.
Anschließend wird auf DBTune nach einer Ressource gesucht, deren rdfs:label mit der Eingabe des Nutzers übereinstimmt und die außerdem als rdf:type den Eintrag mo:MusicArtist hat. Wird eine Ressource gefunden, erhält das System die Musicbrainz ID des Artists sowie den Link zur DBPedia Ressource.
Für den Fall, dass sich ein Artist nicht auf DBTune finden lässt, wird im Musicbrainz-Dump nach dem Artist gesucht. Statt rdfs:label kommt hier foaf:name zum Einsatz. Da im Musicbrainz-Dump kein Verweis auf den entsprechenden DBPedia-Eintrag vorhanden ist, muss auf der DBPedia selbst nach der entsprechenden Ressource gesucht werden.
Ist der Link zur DBPedia Ressource des jeweiligen Künstlers vorhanden, kann gezielt nach Recommendations gesucht werden. Dazu werden zunächst alle aktuellen sowie ehemaligen Mitglieder der Band via dbpprop:currentMembers oder dbpedia-owl:bandMembers  bzw. dbpprop:pastMembers oder dbpedia-owl:formerBandMember abgefragt. Im Anschluss werden für jedes so gefundene Mitglied folgende Relationen überprüft:
die Membership-Relation (s.o), die Producer-Relation (dbprop:producer oder dbpedia-owl:producer), die Composer-Relation (dbpedia-owl:composer) und die Writer-Relation (dbpedia-owl:writer oder dbpprop:writer). Grundsätzlich wird für jede Relation nach Bands oder Künstlern gesucht, in denen ein aktuelles oder ehemaliges Mitglied der Band zur Zeit spielt, gespielt hat bzw. nach Bands, für die ein aktuelles oder ehemaliges Mitglied der Band produziert oder einen Song geschrieben bzw. komponiert hat. Wird bei einer dieser Abfragen eine Recommendation gefunden, gibt es zwei Möglichkeiten: ist der gefundene Artist noch nicht in der Liste der recommended Artists enthalten, wird er der Liste samt des Grundes, warum er empfohlen wird, hinzugefügt. Sollte der gefundene Interpret bereits in der Liste enthalten sein, wird diesem Artist lediglich der Grund hinzugefügt, weshalb er gefunden wurde. 
Nachdem alle Relationen überprüft wurden, wird anhand eines Voting-Algorithmusses über die Relevanz der einzelnen Recommendations entschieden. Dafür wird der Familiarity-Wert genutzt, den die echoNest-API bereit stellt, sowie die dbpedia-Pageranks.. Die echoNest-Familiarity ist ein von echoNest errechneter Wert, der aussagt, wie bekannt die Band ist (siehe Q11, die referenz muss vllt woanders hin).
Darüber hinaus wird jeder Relation ein Faktor zugeordnet, der in die Berechnung mit einfließt. Diese Faktoren haben die Aufgabe, die Wichtigkeit der Relationen untereinander zu bewerten. Die Membership-Relation für aktuelle Bands hat den höchsten Faktor, gefolgt von der Membership-Relation für ehemalige Bands, der Producer-Relation und der Writer- und der Composer-Relation, welche gleichwertig sind. Geht diese Relation von einem aktuellen Mitglied der Band aus, so ist der Faktor verdoppelt so hoch wie für ein ehemaliges Mitglied. Am Ende werden der dbpedia-Pagerank, die echonest-Familiarity und der Relationsfaktor miteinander multipliziert. Die Recommendation mit dem höchsten Wert steht am Ende in der Liste der Vorschläge oben und die mit dem niedrigsten Wert unten.
Nach Abschluss des Votings wird der Parser gestartet, welcher alle gefundenen Informationen für einen Artist in eine Turtle-Datei schreibt.
Wurden alle Schritte erledigt, kann die Seite gerendert und ausgegeben werden (siehe Abb. x).


Bild einer fertigen Seite